# Create the result list with the correct column names and values
result <- list(
col1_name = col1_stats,
col2_name = col2_stats,
correlation_matrix = correlation_matrix
)
# Rename the list elements with the actual column names
names(result) <- c(col1_name, col2_name, "correlation_matrix")
return(result)
}
mark_my_assignment()
# Load necessary library
library(dplyr)
install.packages("dyplr")
# Load necessary library
library(dplyr)
install.packages("dplyr")
library(dplyr)
# Load necessary library
library(dplyr)
# Function to implement Dijkstra's Algorithm
dijkstra <- function(graph, init_node) {
# Get unique nodes in the graph
nodes <- unique(c(graph$v1, graph$v2))
# Initialize distances to infinity and set the distance to the initial node as 0
distances <- rep(Inf, length(nodes))
names(distances) <- nodes
distances[as.character(init_node)] <- 0
# Keep track of the nodes to visit
to_visit <- nodes
# While there are still nodes to visit
while(length(to_visit) > 0) {
# Get the node with the smallest tentative distance
current_node <- to_visit[which.min(distances[to_visit])]
# Remove it from the list of nodes to visit
to_visit <- setdiff(to_visit, current_node)
# Get neighbors of the current node
neighbors <- graph %>% filter(v1 == current_node) %>% select(v2, w)
# Update the distances to the neighbors
for (i in 1:nrow(neighbors)) {
neighbor <- neighbors$v2[i]
weight <- neighbors$w[i]
new_distance <- distances[as.character(current_node)] + weight
if (new_distance < distances[as.character(neighbor)]) {
distances[as.character(neighbor)] <- new_distance
}
}
}
# Return the distances from the initial node to all other nodes
return(distances)
}
# Example graph from the image
wiki_graph <- data.frame(
v1 = c(1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6),
v2 = c(2, 3, 3, 4, 1, 4, 6, 2, 5, 6, 4, 6, 3, 5, 4),
w  = c(7, 9, 10, 15, 9, 11, 2, 15, 6, 6, 9, 14, 2, 9, 6)
)
# Test the function with initial node 1
dijkstra(wiki_graph, 1)
# Test the function with initial node 3
dijkstra(wiki_graph, 3)
distance
distances
print(distances)
dijkstra <- function(graph, init_node) {
nodes <- unique(c(graph$v1, graph$v2))
# Initialize distances to infinity and set distance to initial node as 0
distances <- rep(Inf, length(nodes))
names(distances) <- nodes
distances[as.character(init_node)] <- 0
# Keep track of the nodes to visit
to_visit <- nodes
# While there are still nodes to visit
while(length(to_visit) > 0) {
# Get the node with the smallest tentative distance
current_node <- to_visit[which.min(distances[to_visit])]
# Remove it from the list of nodes to visit
to_visit <- setdiff(to_visit, current_node)
# Get neighbors of the current node
neighbors <- graph %>% filter(v1 == current_node) %>% select(v2, w)
# Update the distances to the neighbors
for (i in 1:nrow(neighbors)) {
neighbor <- neighbors$v2[i]
weight <- neighbors$w[i]
new_distance <- distances[as.character(current_node)] + weight
if (new_distance < distances[as.character(neighbor)]) {
distances[as.character(neighbor)] <- new_distance
}
}
}
# Return the distances from the initial node to all other nodes
return(distances)
}
print(distances)
dijkstra <- function(graph, init_node) {
nodes <- unique(c(graph$v1, graph$v2))
# Initialize distances to infinity and set distance to initial node as 0
distances <- rep(Inf, length(nodes))
names(distances) <- nodes
distances[as.character(init_node)] <- 0
# Keep track of the nodes to visit
to_visit <- nodes
# While there are still nodes to visit
while(length(to_visit) > 0) {
# Get the node with the smallest tentative distance
current_node <- to_visit[which.min(distances[to_visit])]
# Remove it from the list of nodes to visit
to_visit <- setdiff(to_visit, current_node)
# Get neighbors of the current node
neighbors <- graph %>% filter(v1 == current_node) %>% select(v2, w)
# Update the distances to the neighbors
for (i in 1:nrow(neighbors)) {
neighbor <- neighbors$v2[i]
weight <- neighbors$w[i]
new_distance <- distances[as.character(current_node)] + weight
if (new_distance < distances[as.character(neighbor)]) {
distances[as.character(neighbor)] <- new_distance
}
}
}
# Return the distances from the initial node to all other nodes
return(distances)
}
# Call the function for initial node 1 and print the result
result <- dijkstra(wiki_graph, 1)
print(result)
package.skeleton(name='yourpackagename')
dijkstra <- function(graph, init_node) {
# Get unique nodes in the graph
nodes <- unique(c(graph$v1, graph$v2))
# Initialize distances to infinity and set the distance to the initial node as 0
distances <- rep(Inf, length(nodes))
names(distances) <- nodes
distances[as.character(init_node)] <- 0
# Keep track of the nodes to visit
to_visit <- nodes
# While there are still nodes to visit
while(length(to_visit) > 0) {
# Get the node with the smallest tentative distance
current_node <- to_visit[which.min(distances[to_visit])]
# Remove it from the list of nodes to visit
to_visit <- setdiff(to_visit, current_node)
# Get neighbors of the current node using base R subsetting
neighbors <- subset(graph, v1 == current_node, select = c(v2, w))
# Update the distances to the neighbors
for (i in 1:nrow(neighbors)) {
neighbor <- neighbors$v2[i]
weight <- neighbors$w[i]
new_distance <- distances[as.character(current_node)] + weight
if (new_distance < distances[as.character(neighbor)]) {
distances[as.character(neighbor)] <- new_distance
}
}
}
# Return the distances from the initial node to all other nodes
return(distances)
}
# Example graph
wiki_graph <- data.frame(
v1 = c(1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6),
v2 = c(2, 3, 3, 4, 1, 4, 6, 2, 5, 6, 4, 6, 3, 5, 4),
w  = c(7, 9, 10, 15, 9, 11, 2, 15, 6, 6, 9, 14, 2, 9, 6)
)
# Test the function with initial node 1
dijkstra(wiki_graph, 1)
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
library(R6)
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
install.packages(c("httr", "jsonlite", "R6", "sf", "dplyr", "plotly", "ggplot2"))
library(httr)
library(jsonlite)
library(R6)
library(sf)
install.packages(c("httr", "jsonlite", "R6", "sf", "dplyr", "plotly", "ggplot2"))
install.packages("sf")
library(sf)
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
setwd("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5")
library(httr)
library(jsonlite)
library(R6)
library(sf)
library(dplyr)
library(plotly)
library(ggplot2)
# Create instances of the handlers
api_handler <- kolada_handler$new()
map_handler <- map_handler$new()
# Get the KPI data (for example, life expectancy data with KPI ID "N00923")
kolada_data <- api_handler$get_kpi("N00923")
# Convert to a data frame if it is in list format and extract values
if (class(kolada_data) == "list") {
kolada_data <- as.data.frame(kolada_data)
}
# Extract the 'value' from the nested list structure
kolada_data$value <- sapply(kolada_data$values, function(x) x$value)
# Merge the KPI data with the shapefile data
merged_data <- map_handler$merge_data(kolada_data = kolada_data)
htmlwidgets::saveWidget(p_interactive, "plot.html")
initialize = function(){
self$shapefile_path = "../Advanced-Programming-R-Lab-5/resources/shapefiles/alla_kommuner.shp"
self$shapefile_data = self$load_shapefile(self$shapefile_path)
print(self$shapefile_data)  # Check if shapefile data is loaded properly
}
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
#' @importFrom httr GET content
#' @importFrom jsonlite fromJSON
#' @importFrom R6 R6Class
#' @importFrom sf st_read
#' @importFrom dplyr inner_join
#' @importFrom plotly ggplotly
kolada_handler <- R6Class("kolada_handler",
public = list(
#' @description
#' Constructor function for the kolada handler
#' Takes no arguments as there is no requirement for an API key
#' All calls to the API endpoints are made through a kolada_handler instance.
#' @return A kolada_handler object which interacts with the API endpoints
#' @export
initialize = function(){
},
#' @description
#' Parses the API response to be a usable R object.
#' @param response response as received from API endpoint
#' @return parsed_response through JSON parsing
parse_response = function(response){
data <- content(response, as = "text")
parsed_data = fromJSON(data)
return (parsed_data)
},
#' @description
#' Retrieves a list of available municipalities based on string input
#' and presumably fuzzy string matching.
#' Response contains the id of the municipalities which are needed for further processing.
#' @param municipality_str Search string for municipality
#' @return list of municipalities with similar or equal name
parse_municipality = function(municipality_str){
endpoint = "http://api.kolada.se/v2/municipality?title="
response <- GET(paste0(endpoint, municipality_str))
data = self$parse_response(response)
return (data)
},
#' @description
#' Function that retrieves all information for a specific municipality
#' @param municipality_id integer id as used by kolada and retrieved by parse_municipality method
#' @@return Information regarding municipality
get_municipality = function(municipality_id){
endpoint = "https://api.kolada.se/v2/data/municipality/"
response <- GET(paste0(endpoint, municipality_id))
data = self$parse_response(response)
return(data)
},
parse_kpi = function(kpi_string){
endpoint = "http://api.kolada.se/v2/kpi?title="
response <- GET(paste0(endpoint, kpi_string))
data = self$parse_response(response)
return(data)
},
get_kpi = function(kpi_id){
endpoint = "http://api.kolada.se/v2/data/kpi/"
print(paste0(endpoint, kpi_id))
response <- GET(paste0(endpoint, kpi_id, "/year/2023"))
data = self$parse_response(response)
return(data$values)
}
)
)
#' @importFrom httr GET content
#' @importFrom jsonlite fromJSON
#' @importFrom R6 R6Class
#' @importFrom sf st_read
#' @importFrom dplyr inner_join
#' @importFrom plotly ggplotly
kolada_handler <- R6Class("kolada_handler",
public = list(
#' @description
#' Constructor function for the kolada handler
#' Takes no arguments as there is no requirement for an API key
#' All calls to the API endpoints are made through a kolada_handler instance.
#' @return A kolada_handler object which interacts with the API endpoints
#' @export
initialize = function(){
},
#' @description
#' Parses the API response to be a usable R object.
#' @param response response as received from API endpoint
#' @return parsed_response through JSON parsing
parse_response = function(response){
data <- content(response, as = "text")
parsed_data = fromJSON(data)
return (parsed_data)
},
#' @description
#' Retrieves a list of available municipalities based on string input
#' and presumably fuzzy string matching.
#' Response contains the id of the municipalities which are needed for further processing.
#' @param municipality_str Search string for municipality
#' @return list of municipalities with similar or equal name
parse_municipality = function(municipality_str){
endpoint = "http://api.kolada.se/v2/municipality?title="
response <- GET(paste0(endpoint, municipality_str))
data = self$parse_response(response)
return (data)
},
#' @description
#' Function that retrieves all information for a specific municipality
#' @param municipality_id integer id as used by kolada and retrieved by parse_municipality method
#' @@return Information regarding municipality
get_municipality = function(municipality_id){
endpoint = "https://api.kolada.se/v2/data/municipality/"
response <- GET(paste0(endpoint, municipality_id))
data = self$parse_response(response)
return(data)
},
parse_kpi = function(kpi_string){
endpoint = "http://api.kolada.se/v2/kpi?title="
response <- GET(paste0(endpoint, kpi_string))
data = self$parse_response(response)
return(data)
},
get_kpi = function(kpi_id){
endpoint = "http://api.kolada.se/v2/data/kpi/"
print(paste0(endpoint, kpi_id))
response <- GET(paste0(endpoint, kpi_id, "/year/2023"))
data = self$parse_response(response)
return(data$values)
}
)
)
map_handler <- R6Class("map_handler",
public = list(
shapefile_data = NULL,
shapefile_path = NULL,
load_shapefile = function(path){
return(st_read(path))
},
initialize = function(){
self$shapefile_path = "../Advanced-Programming-R-Lab-5/resources/shapefiles/alla_kommuner.shp"
self$shapefile_data = self$load_shapefile(self$shapefile_path)
},
merge_data = function(kolada_data){
merged_data <- shapefile_data %>%
inner_join(kolada_data, by = c("ID" = "municipality"))
},
plot_data = function(merged_data, title){
p <- ggplot(data = merged_data) +
geom_sf(aes(fill = value, text = paste("Municipality: ", KOM_NAMN, "<br>", "Value: ", value))) +
scale_fill_viridis_c() +
theme_minimal() +
ggtitle(title)
p_interactive <- ggplotly(p, tooltip = "text")
print(p_interactive)
}
)
)
# Example usage
api_handler = kolada_handler$new()
map_handler = map_handler$new()
kolada_data = api_handler$get_kpi("N00923") # life expectancy data
if (class(kolada_data) == "list") {
kolada_data <- as.data.frame(kolada_data)
}
kolada_data$value <- sapply(kolada_data$values, function(x) x$value)
merged_data = map_handler$merge_data(kolada_data = kolada_data)
plot(data)
View(kolada_data)
library(httr)
library(jsonlite)
library(R6)
library(sf)
library(dplyr)
library(plotly)
library(ggplot2)
library(httr)
library(jsonlite)
library(R6)
library(sf)
library(dplyr)
library(plotly)
library(ggplot2)
install.packages("httr")
kolada_handler <- R6Class("kolada_handler",
public = list(
#' @description
#' Constructor function for the kolada handler
#' Takes no arguments as there is no requirement for an API key
#' All calls to the API endpoints are made through a kolada_handler instance.
#' @return A kolada_handler object which interacts with the API endpoints
#' @export
initialize = function(){
},
#' @description
#' Parses the API response to be a usable R object.
#' @param response response as received from API endpoint
#' @return parsed_response through JSON parsing
parse_response = function(response){
data <- content(response, as = "text")
parsed_data = fromJSON(data)
return (parsed_data)
},
#' @description
#' Retrieves a list of available municipalities based on string input
#' and presumably fuzzy string matching.
#' Response contains the id of the municipalities which are needed for further processing.
#' @param municipality_str Search string for municipality
#' @return list of municipalities with similar or equal name
parse_municipality = function(municipality_str){
endpoint = "http://api.kolada.se/v2/municipality?title="
response <- GET(paste0(endpoint, municipality_str))
data = self$parse_response(response)
return (data)
},
#' @description
#' Function that retrieves all information for a specific municipality
#' @param municipality_id integer id as used by kolada and retrieved by parse_municipality method
#' @@return Information regarding municipality
get_municipality = function(municipality_id){
endpoint = "https://api.kolada.se/v2/data/municipality/"
response <- GET(paste0(endpoint, municipality_id))
data = self$parse_response(response)
return(data)
},
parse_kpi = function(kpi_string){
endpoint = "http://api.kolada.se/v2/kpi?title="
response <- GET(paste0(endpoint, kpi_string))
data = self$parse_response(response)
return(data)
},
get_kpi = function(kpi_id){
endpoint = "http://api.kolada.se/v2/data/kpi/"
print(paste0(endpoint, kpi_id))
response <- GET(paste0(endpoint, kpi_id, "/year/2023"))
data = self$parse_response(response)
return(data$values)
}
)
)
map_handler <- R6Class("map_handler",
public = list(
shapefile_data = NULL,
shapefile_path = NULL,
load_shapefile = function(path){
return(st_read(path))
},
initialize = function(){
self$shapefile_path = "../Advanced-Programming-R-Lab-5/resources/shapefiles/alla_kommuner.shp"
self$shapefile_data = self$load_shapefile(self$shapefile_path)
},
merge_data = function(kolada_data){
merged_data <- shapefile_data %>%
inner_join(kolada_data, by = c("ID" = "municipality"))
},
plot_data = function(merged_data, title){
p <- ggplot(data = merged_data) +
geom_sf(aes(fill = value, text = paste("Municipality: ", KOM_NAMN, "<br>", "Value: ", value))) +
scale_fill_viridis_c() +
theme_minimal() +
ggtitle(title)
p_interactive <- ggplotly(p, tooltip = "text")
print(p_interactive)
}
)
)
# Example usage
api_handler = kolada_handler$new()
map_handler = map_handler$new()
kolada_data = api_handler$get_kpi("N00923") # life expectancy data
if (class(kolada_data) == "list") {
kolada_data <- as.data.frame(kolada_data)
}
kolada_data$value <- sapply(kolada_data$values, function(x) x$value)
merged_data = map_handler$merge_data(kolada_data = kolada_data)
View(merged_data)
merged_data = map_handler$merge_data(kolada_data = kolada_data)
map_handler = map_handler$new()
api_handler = kolada_handler$new()
map_handler = map_handler$new()
api_handler = kolada_handler$new()
map_handler = map_handler$new()
rm(map_handler)  # Remove any existing object with the name map_handler
map_handler <- map_handler$new()
map_handler <- R6Class("map_handler",
public = list(
shapefile_data = NULL,
shapefile_path = NULL,
initialize = function(){
self$shapefile_path = "../Advanced-Programming-R-Lab-5/resources/shapefiles/alla_kommuner.shp"
self$shapefile_data = self$load_shapefile(self$shapefile_path)
},
load_shapefile = function(path){
return(st_read(path))
},
merge_data = function(kolada_data){
merged_data <- self$shapefile_data %>%
inner_join(kolada_data, by = c("ID" = "municipality"))
return(merged_data)
},
plot_data = function(merged_data, title){
p <- ggplot(data = merged_data) +
geom_sf(aes(fill = value, text = paste("Municipality: ", KOM_NAMN, "<br>", "Value: ", value))) +
scale_fill_viridis_c() +
theme_minimal() +
ggtitle(title)
p_interactive <- ggplotly(p, tooltip = "text")
print(p_interactive)
}
)
)
map_handler <- map_handler$new()
source("C:/Users/victo/OneDrive/Bureau/A1_SML/Advanced R programming/Assignments/Advanced-Programming-R-Lab-5/R/main.R")
